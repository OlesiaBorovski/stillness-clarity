<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Stillness = Clarity</title>
  <style>
    html, body { margin: 0; height: 100%; background: #07070a; overflow: hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: rgba(255,255,255,0.88);
    }
    #canvas { display:block; width: 100%; height: 100%; }

    #ui {
      position: fixed; top: 16px; left: 16px; z-index: 20;
      display: flex; gap: 10px; align-items: center;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px; padding: 10px 12px;
      backdrop-filter: blur(10px);
    }
    #title { font-weight: 780; letter-spacing: 0.2px; white-space: nowrap; }
    button {
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.92);
      border-radius: 12px; padding: 10px 12px;
      cursor: pointer; font-weight: 680;
    }
    button:hover { background: rgba(255,255,255,0.14); }
    #status { opacity: 0.75; font-size: 12px; margin-left: 6px; white-space: nowrap; }

    #panel {
      position: fixed; top: 16px; right: 16px; z-index: 20;
      width: min(360px, calc(100% - 32px));
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 16px; padding: 12px 12px 10px;
      backdrop-filter: blur(10px);
    }
    #panelHeader { display:flex; align-items:center; justify-content: space-between; gap: 10px; }
    #panelHeader .label { font-weight: 780; letter-spacing: 0.2px; }
    #panelToggle { padding: 8px 10px; border-radius: 12px; }

    .row { display:flex; align-items:center; justify-content: space-between; gap: 10px; margin-top: 10px; }
    .row label { font-size: 12px; opacity: 0.82; }
    .row .value { font-size: 12px; opacity: 0.72; min-width: 40px; text-align:right; }
    input[type="range"] { width: 60%; }
    select {
      width: 60%;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.92);
      border-radius: 12px;
      padding: 8px 10px;
      outline: none;
    }
    #hint {
      position: fixed; bottom: 18px; left: 16px; z-index: 20;
      max-width: min(700px, calc(100% - 32px));
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px; padding: 12px 14px;
      line-height: 1.35; backdrop-filter: blur(10px);
    }
    #hint strong { font-weight: 820; }
    #hint kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 2px 6px; border-radius: 8px; font-size: 12px;
    }
    .hidden { display:none; }
  </style>
</head>
<body>

  <div id="ui">
    <div id="title">Stillness = Clarity</div>
    <button id="startBtn">START AUDIO</button>
    <button id="muteBtn" disabled>MUTE</button>
    <button id="fsBtn">FULLSCREEN</button>
    <span id="status">audio: off</span>
  </div>

  <div id="panel">
    <div id="panelHeader">
      <div class="label">Controls</div>
      <button id="panelToggle">HIDE</button>
    </div>

    <div id="panelBody">
      <div class="row">
        <label for="preset">Mood preset</label>
        <select id="preset">
          <option value="calm">Calm (aurora)</option>
          <option value="neon">Neon (electric)</option>
          <option value="embers">Embers (warm)</option>
          <option value="ice">Ice (cool)</option>
        </select>
      </div>

      <div class="row">
        <label for="scale">Scale</label>
        <select id="scale">
          <option value="minor">Minor</option>
          <option value="pentatonic">Minor Pentatonic</option>
          <option value="dorian">Dorian</option>
          <option value="major">Major</option>
        </select>
      </div>

      <div class="row">
        <label for="root">Root note</label>
        <select id="root">
          <option value="A">A</option>
          <option value="C">C</option>
          <option value="D">D</option>
          <option value="E">E</option>
          <option value="F">F</option>
          <option value="G">G</option>
        </select>
      </div>

      <div class="row">
        <label for="sensitivity">Movement sensitivity</label>
        <input id="sensitivity" type="range" min="20" max="90" value="45" />
        <div class="value" id="sensVal">45</div>
      </div>

      <div class="row">
        <label for="proximityMode">Distance → tension</label>
        <input id="proximityMode" type="range" min="0" max="100" value="70" />
        <div class="value" id="proxVal">70</div>
      </div>

      <div class="row">
        <label for="reverbAmt">Reverb</label>
        <input id="reverbAmt" type="range" min="0" max="100" value="35" />
        <div class="value" id="revVal">35</div>
      </div>

      <div class="row">
        <label for="colorAmt">Color intensity</label>
        <input id="colorAmt" type="range" min="0" max="100" value="65" />
        <div class="value" id="colVal">65</div>
      </div>

      <div class="row">
        <label for="visualIntensity">Visual intensity</label>
        <input id="visualIntensity" type="range" min="0" max="100" value="60" />
        <div class="value" id="visVal">60</div>
      </div>
    </div>
  </div>

  <div id="hint">
    <strong>How it works:</strong> Movement makes the sound cloudy. Stillness triggers a soft “arrival” note.
    Distance from the center adds musical tension. Press <kbd>H</kbd> to hide hints.
  </div>

  <canvas id="canvas"></canvas>

<script>
(() => {
  // -------------------- Canvas --------------------
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // -------------------- UI --------------------
  const startBtn = document.getElementById('startBtn');
  const muteBtn  = document.getElementById('muteBtn');
  const fsBtn    = document.getElementById('fsBtn');
  const statusEl = document.getElementById('status');
  const hintEl   = document.getElementById('hint');

  const presetEl = document.getElementById('preset');
  const scaleEl  = document.getElementById('scale');
  const rootEl   = document.getElementById('root');

  const sensitivityEl = document.getElementById('sensitivity');
  const proximityEl   = document.getElementById('proximityMode');
  const reverbEl      = document.getElementById('reverbAmt');
  const colorEl       = document.getElementById('colorAmt');
  const visualEl      = document.getElementById('visualIntensity');

  const sensVal = document.getElementById('sensVal');
  const proxVal = document.getElementById('proxVal');
  const revVal  = document.getElementById('revVal');
  const colVal  = document.getElementById('colVal');
  const visVal  = document.getElementById('visVal');

  const panelToggle = document.getElementById('panelToggle');
  const panelBody   = document.getElementById('panelBody');

  function syncVals() {
    sensVal.textContent = sensitivityEl.value;
    proxVal.textContent = proximityEl.value;
    revVal.textContent  = reverbEl.value;
    colVal.textContent  = colorEl.value;
    visVal.textContent  = visualEl.value;
  }
  [sensitivityEl, proximityEl, reverbEl, colorEl, visualEl].forEach(el => el.addEventListener('input', syncVals));
  syncVals();

  panelToggle.addEventListener('click', () => {
    const hidden = panelBody.classList.toggle('hidden');
    panelToggle.textContent = hidden ? "SHOW" : "HIDE";
  });

  document.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'h') hintEl.classList.toggle('hidden');
  });

  fsBtn.addEventListener('click', async () => {
    try {
      if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
      else await document.exitFullscreen();
    } catch (_) {}
  });

  // -------------------- Interaction state --------------------
  let mx = window.innerWidth * 0.5;
  let my = window.innerHeight * 0.5;
  let pmx = mx, pmy = my;

  window.addEventListener('mousemove', (e) => { mx = e.clientX; my = e.clientY; }, { passive: true });
  window.addEventListener('touchmove', (e) => {
    if (!e.touches || !e.touches[0]) return;
    mx = e.touches[0].clientX;
    my = e.touches[0].clientY;
  }, { passive: true });

  // -------------------- Helpers --------------------
  function mapClamp(v, inMin, inMax, outMin, outMax) {
    const t = Math.min(1, Math.max(0, (v - inMin) / (inMax - inMin)));
    return outMin + t * (outMax - outMin);
  }

  // HSV -> RGB string (nice for controlled color shifts)
  function hsvToRgb(h, s, v) {
    h = ((h % 360) + 360) % 360;
    const c = v * s;
    const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
    const m = v - c;
    let r=0,g=0,b=0;
    if (h < 60) [r,g,b] = [c,x,0];
    else if (h < 120) [r,g,b] = [x,c,0];
    else if (h < 180) [r,g,b] = [0,c,x];
    else if (h < 240) [r,g,b] = [0,x,c];
    else if (h < 300) [r,g,b] = [x,0,c];
    else [r,g,b] = [c,0,x];
    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);
    return { r, g, b };
  }

  function rgba({r,g,b}, a) { return `rgba(${r},${g},${b},${a})`; }

  // -------------------- Musical quantization --------------------
  const NOTE_TO_SEMITONE = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 };

  const SCALES = {
    major:      [0,2,4,5,7,9,11],
    minor:      [0,2,3,5,7,8,10],        // natural minor
    dorian:     [0,2,3,5,7,9,10],
    pentatonic: [0,3,5,7,10]             // minor pentatonic
  };

  function midiToFreq(m) { return 440 * Math.pow(2, (m - 69) / 12); }

  function quantizeMidiToScale(midi, rootSemitone, scale) {
    // Find nearest note in scale (across octaves)
    const scaleSteps = SCALES[scale] || SCALES.minor;
    // Normalize to relative semitone from root
    const rel = midi - rootSemitone;
    const octave = Math.floor(rel / 12);
    const within = rel - octave * 12;

    // Find closest scale degree within the octave
    let best = scaleSteps[0];
    let bestDist = Infinity;
    for (const step of scaleSteps) {
      const dist = Math.abs(step - within);
      if (dist < bestDist) { bestDist = dist; best = step; }
    }
    const quant = rootSemitone + octave * 12 + best;
    return quant;
  }

  // -------------------- Audio --------------------
  let audioCtx = null;
  let started = false;
  let isMuted = false;

  let osc1, osc2, padOsc, lfo;
  let filter;
  let master, dryGain, wetGain;
  let analyser;
  let noiseSrc, noiseGain;
  let convolver;

  const freqData = new Uint8Array(512);
  let rms = 0;

  function makeImpulse(ctx, seconds = 2.4, decay = 3.3) {
    const sr = ctx.sampleRate;
    const length = Math.floor(sr * seconds);
    const impulse = ctx.createBuffer(2, length, sr);
    for (let ch = 0; ch < 2; ch++) {
      const data = impulse.getChannelData(ch);
      for (let i = 0; i < length; i++) {
        const t = i / length;
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, decay);
      }
    }
    return impulse;
  }

  function makeNoiseBuffer(ctx, seconds = 2) {
    const sr = ctx.sampleRate;
    const len = Math.floor(sr * seconds);
    const buffer = ctx.createBuffer(1, len, sr);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < len; i++) data[i] = (Math.random() * 2 - 1);
    return buffer;
  }

  function applyReverb() {
    if (!audioCtx || !wetGain || !dryGain) return;
    const amt = Number(reverbEl.value) / 100;
    const dry = 0.98 - amt * 0.40;
    const wet = amt * 0.75;
    dryGain.gain.setTargetAtTime(dry, audioCtx.currentTime, 0.06);
    wetGain.gain.setTargetAtTime(wet, audioCtx.currentTime, 0.06);
  }

  function getRootMidi() {
    const root = rootEl.value;
    const semi = NOTE_TO_SEMITONE[root];
    // Choose a comfortable register: around A3 (57)–A4 (69)
    // We'll map root to octave 3/4 depending on letter.
    // Use C4 = 60 baseline: root at octave 3 (48+) or 4 (60+) can be tuned.
    // We'll pick octave 3 (48) for darker, bump up if needed.
    const baseOct = (root === "C" || root === "D" || root === "E") ? 4 : 3;
    return baseOct * 12 + semi; // e.g., A3 = 57, C4 = 60
  }

  // “Arrival” pluck: triggered when motion drops below threshold
  let lastStill = false;
  function triggerPluck(freq, brightness, hue) {
    if (!audioCtx || !started) return;
    const now = audioCtx.currentTime;

    const pluckOsc = audioCtx.createOscillator();
    pluckOsc.type = "sine";
    pluckOsc.frequency.setValueAtTime(freq * 2, now);

    const pluckGain = audioCtx.createGain();
    pluckGain.gain.setValueAtTime(0.0001, now);
    pluckGain.gain.exponentialRampToValueAtTime(0.18, now + 0.015);
    pluckGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);

    const pluckFilter = audioCtx.createBiquadFilter();
    pluckFilter.type = "bandpass";
    pluckFilter.frequency.setValueAtTime(Math.max(300, brightness), now);
    pluckFilter.Q.setValueAtTime(4.5, now);

    // Add tiny shimmer with a second oscillator detuned
    const pluckOsc2 = audioCtx.createOscillator();
    pluckOsc2.type = "triangle";
    pluckOsc2.frequency.setValueAtTime(freq * 3, now);
    pluckOsc2.detune.setValueAtTime(mapClamp(hue, 0, 360, -8, 8), now);

    const mix = audioCtx.createGain();
    mix.gain.setValueAtTime(1.0, now);

    pluckOsc.connect(mix);
    pluckOsc2.connect(mix);
    mix.connect(pluckFilter);
    pluckFilter.connect(dryGain);
    pluckFilter.connect(convolver); // shares reverb

    pluckOsc.start(now);
    pluckOsc2.start(now);
    pluckOsc.stop(now + 0.5);
    pluckOsc2.stop(now + 0.5);
  }

  async function startAudio() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // Main tone: two oscillators (root + fifth)
    osc1 = audioCtx.createOscillator();
    osc2 = audioCtx.createOscillator();
    osc1.type = "triangle";
    osc2.type = "sine";

    // Soft pad layer (very quiet, makes it feel “real”)
    padOsc = audioCtx.createOscillator();
    padOsc.type = "sawtooth";

    // LFO for slow breathing
    lfo = audioCtx.createOscillator();
    lfo.type = "sine";
    lfo.frequency.value = 0.10;
    const lfoGain = audioCtx.createGain();
    lfoGain.gain.value = 10;
    lfo.connect(lfoGain);
    lfoGain.connect(osc1.detune);
    lfoGain.connect(osc2.detune);
    lfoGain.connect(padOsc.detune);

    // Shared filter (clarity)
    filter = audioCtx.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.value = 1200;
    filter.Q.value = 0.9;

    // Noise for cloudiness
    noiseSrc = audioCtx.createBufferSource();
    noiseSrc.buffer = makeNoiseBuffer(audioCtx, 2);
    noiseSrc.loop = true;
    noiseGain = audioCtx.createGain();
    noiseGain.gain.value = 0;

    // Reverb
    convolver = audioCtx.createConvolver();
    convolver.buffer = makeImpulse(audioCtx, 2.4, 3.4);

    // Mix
    master = audioCtx.createGain();
    master.gain.value = 0.22;

    dryGain = audioCtx.createGain();
    wetGain = audioCtx.createGain();
    dryGain.gain.value = 0.85;
    wetGain.gain.value = 0.35;

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;

    // Tone bus
    const toneBus = audioCtx.createGain();
    toneBus.gain.value = 1.0;

    // Pad is softer
    const padGain = audioCtx.createGain();
    padGain.gain.value = 0.08;

    osc1.connect(toneBus);
    osc2.connect(toneBus);
    padOsc.connect(padGain);
    padGain.connect(toneBus);

    toneBus.connect(filter);

    // Noise goes into filter too
    noiseSrc.connect(noiseGain);
    noiseGain.connect(filter);

    // Filter to dry + wet
    filter.connect(dryGain);
    filter.connect(convolver);
    convolver.connect(wetGain);

    dryGain.connect(master);
    wetGain.connect(master);

    master.connect(analyser);
    analyser.connect(audioCtx.destination);

    // Start
    lfo.start();
    osc1.start();
    osc2.start();
    padOsc.start();
    noiseSrc.start();

    started = true;
    muteBtn.disabled = false;
    startBtn.textContent = "AUDIO ON";
    startBtn.disabled = true;
    statusEl.textContent = "audio: on";

    applyReverb();
  }

  startBtn.addEventListener('click', async () => {
    if (started) return;
    try { await startAudio(); }
    catch (e) {
      console.error(e);
      statusEl.textContent = "audio: blocked";
      alert("Audio couldn't start. Try Chrome and click START AUDIO again.");
    }
  });

  muteBtn.addEventListener('click', () => {
    if (!started) return;
    isMuted = !isMuted;
    master.gain.setTargetAtTime(isMuted ? 0.0 : 0.22, audioCtx.currentTime, 0.02);
    muteBtn.textContent = isMuted ? "UNMUTE" : "MUTE";
    statusEl.textContent = isMuted ? "audio: muted" : "audio: on";
  });

  reverbEl.addEventListener('input', applyReverb);

  fsBtn.addEventListener('click', async () => {
    try {
      if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
      else await document.exitFullscreen();
    } catch (_) {}
  });

  // -------------------- Color presets --------------------
  const COLORSETS = {
    calm:   { h1: 190, h2: 270, h3: 320 }, // teal -> violet -> magenta
    neon:   { h1: 120, h2: 200, h3: 300 }, // green -> cyan -> pink
    embers: { h1: 20,  h2: 45,  h3: 320 }, // orange -> gold -> purple
    ice:    { h1: 200, h2: 220, h3: 260 }  // cool blues
  };

  // -------------------- Visual system --------------------
  const trail = [];
  const sparks = [];
  const TRAIL_MAX = 180;

  function addTrailPoint(x, y, strength, hue) {
    trail.push({ x, y, life: 1, s: strength, h: hue });
    if (trail.length > TRAIL_MAX) trail.shift();
  }

  function spawnSpark(x, y, n, intensity, hue) {
    const count = Math.floor(mapClamp(intensity, 0, 1, 2, n));
    for (let i = 0; i < count; i++) {
      const a = Math.random() * Math.PI * 2;
      const sp = 0.6 + Math.random() * 2.4;
      sparks.push({
        x, y,
        vx: Math.cos(a) * sp,
        vy: Math.sin(a) * sp,
        life: 0.7 + Math.random() * 0.7,
        r: 1 + Math.random() * 2.8,
        h: hue + (Math.random()*18 - 9)
      });
    }
  }

  // -------------------- Animation loop --------------------
  let t = 0;
  let velocity = 0;
  let rawVelocity = 0;

  function animate() {
    t++;

    // Movement
    const dx = mx - pmx;
    const dy = my - pmy;
    rawVelocity = Math.sqrt(dx*dx + dy*dy);
    velocity = velocity * 0.88 + rawVelocity * 0.12;
    pmx = mx; pmy = my;

    const sens = Number(sensitivityEl.value);
    const vMove = Math.min(1, velocity / sens); // 0..1

    // Distance to center
    const cx = window.innerWidth * 0.5;
    const cy = window.innerHeight * 0.5;
    const dist = Math.hypot(mx - cx, my - cy);
    const maxDist = Math.hypot(cx, cy);
    const dNorm = Math.min(1, dist / maxDist);
    const proxStrength = Number(proximityEl.value) / 100;
    const tension = dNorm * proxStrength;

    // Audio energy for pulsing
    if (started && analyser) {
      analyser.getByteFrequencyData(freqData);
      let sum = 0;
      const start = 6, end = 140;
      for (let i = start; i < end; i++) {
        const x = freqData[i] / 255;
        sum += x * x;
      }
      const cur = Math.sqrt(sum / (end - start));
      rms = rms * 0.88 + cur * 0.12;
    } else {
      rms *= 0.95;
    }

    // Colors
    const colors = COLORSETS[presetEl.value] || COLORSETS.calm;
    const colorAmt = Number(colorEl.value) / 100;
    const visIntensity = Number(visualEl.value) / 100;

    // Hue is driven by tension + time
    const baseHue = colors.h1 + (colors.h2 - colors.h1) * tension + Math.sin(t * 0.003) * 10;
    const orbHue = baseHue + (colors.h3 - colors.h2) * Math.max(0, (0.35 - vMove)) * 1.2;

    // -------- Musical audio mapping --------
    if (started && audioCtx) {
      const now = audioCtx.currentTime;

      const rootMidi = getRootMidi();
      const scale = scaleEl.value;

      // Map tension -> target midi range around root (two octaves)
      const targetMidi = rootMidi + 12 + tension * 14; // up to ~a ninth above
      const quantMidi = quantizeMidiToScale(targetMidi, rootMidi, scale);
      const freq = midiToFreq(quantMidi);

      // Fifth
      const fifthMidi = quantizeMidiToScale(quantMidi + 7, rootMidi, scale);
      const freqFifth = midiToFreq(fifthMidi);

      // Movement -> cloudiness
      const cutoff = mapClamp(vMove, 0, 1, 3600, 200);
      const noiseAmt = mapClamp(vMove, 0, 1, 0.0, 0.14);

      // Stillness reward: slightly louder, brighter
      const still = 1 - vMove;
      const cutoff2 = cutoff * (1 + tension * 0.40);
      filter.frequency.setTargetAtTime(Math.max(120, cutoff2), now, 0.03);
      noiseGain.gain.setTargetAtTime(noiseAmt, now, 0.03);

      // Set pitches
      osc1.frequency.setTargetAtTime(freq, now, 0.03);
      osc2.frequency.setTargetAtTime(freqFifth, now, 0.03);
      padOsc.frequency.setTargetAtTime(freq * 0.5, now, 0.05);

      // Master “breath”
      const targetMaster = mapClamp(still, 0, 1, 0.15, 0.24);
      if (!isMuted) master.gain.setTargetAtTime(targetMaster, now, 0.06);

      // Arrival detection: if we cross into "still" zone, trigger a pluck once
      const isStillNow = vMove < 0.055;
      if (isStillNow && !lastStill) {
        const bright = mapClamp(still, 0, 1, 600, 2600) * (1 + tension * 0.2);
        triggerPluck(freq, bright, orbHue);
      }
      lastStill = isStillNow;
    }

    // -------- Background aurora gradient --------
    // Fade (more smear when moving)
    const fade = mapClamp(vMove, 0, 1, 0.12, 0.035);
    ctx.fillStyle = `rgba(7,7,10,${fade})`;
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

    // Draw soft color fields
    if (colorAmt > 0.02) {
      const g1 = ctx.createRadialGradient(cx*0.8, cy*0.7, 20, cx*0.8, cy*0.7, Math.max(cx,cy)*0.95);
      const c1 = hsvToRgb(colors.h1 + Math.sin(t*0.002)*12, 0.65, 0.55);
      const c2 = hsvToRgb(colors.h2 + Math.cos(t*0.0017)*12, 0.65, 0.55);
      g1.addColorStop(0.0, rgba(c1, 0.11 * colorAmt));
      g1.addColorStop(1.0, rgba(c2, 0.00));

      const g2 = ctx.createRadialGradient(cx*1.1, cy*1.1, 30, cx*1.1, cy*1.1, Math.max(cx,cy)*1.1);
      const c3 = hsvToRgb(colors.h3 + Math.sin(t*0.0014)*14, 0.70, 0.55);
      g2.addColorStop(0.0, rgba(c3, 0.10 * colorAmt));
      g2.addColorStop(1.0, rgba(c3, 0.00));

      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.fillStyle = g1; ctx.fillRect(0,0,window.innerWidth,window.innerHeight);
      ctx.fillStyle = g2; ctx.fillRect(0,0,window.innerWidth,window.innerHeight);
      ctx.restore();
    }

    // Trails
    if (rawVelocity > 0.25) addTrailPoint(mx, my, vMove, orbHue);

    // Small spark on “arrival”
    const stopSnap = Math.max(0, (0.14 - vMove));
    if (stopSnap > 0.06 && Math.random() < 0.22) spawnSpark(cx, cy, 12, stopSnap, orbHue);

    // Orb motion
    const jitter = mapClamp(vMove, 0, 1, 0, 22) * (0.55 + 0.55 * visIntensity);
    const jx = (Math.sin(t * 0.09) + Math.sin(t * 0.043)) * jitter * 0.35;
    const jy = (Math.cos(t * 0.08) + Math.cos(t * 0.051)) * jitter * 0.35;

    const audioPulse = mapClamp(rms, 0, 1, 0, 26) * (0.35 + 0.65 * visIntensity);
    const stillPulse = mapClamp(1 - vMove, 0, 1, 5, 18) * (0.55 + 0.45*Math.sin(t*0.05));
    const tensionSize = mapClamp(dNorm, 0, 1, 0, 18) * proxStrength;
    const orbR = 46 + stillPulse + audioPulse + tensionSize;

    // Draw colored trails
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (let i = 0; i < trail.length; i++) {
      const p = trail[i];
      p.life *= 0.985;
      const a = p.life * mapClamp(p.s, 0, 1, 0.06, 0.18) * (0.6 + 0.6*visIntensity);
      const r = 1.8 + p.s * 2.2 + rms * 2.2;
      const col = hsvToRgb(p.h, 0.75 * colorAmt, 0.90);
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
      ctx.fillStyle = rgba(col, a);
      ctx.fill();
    }
    ctx.restore();

    // Sparks
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (let i = sparks.length - 1; i >= 0; i--) {
      const s = sparks[i];
      s.x += s.vx; s.y += s.vy;
      s.vx *= 0.98; s.vy *= 0.98;
      s.life *= 0.97;
      const a = s.life * 0.35 * (0.45 + 0.8 * visIntensity);
      const col = hsvToRgb(s.h, 0.80 * colorAmt, 0.95);
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
      ctx.fillStyle = rgba(col, a);
      ctx.fill();
      if (s.life < 0.05) sparks.splice(i, 1);
    }
    ctx.restore();

    // Orb glow with color
    const coreCol = hsvToRgb(orbHue, 0.45 * colorAmt, 1.0);
    const edgeCol = hsvToRgb(orbHue + 30, 0.70 * colorAmt, 1.0);

    const grad = ctx.createRadialGradient(cx + jx, cy + jy, 2, cx + jx, cy + jy, orbR * 2.4);
    const coreA = mapClamp(1 - vMove, 0, 1, 0.95, 0.55);
    const edgeA = mapClamp(1 - vMove, 0, 1, 0.24, 0.06);

    grad.addColorStop(0.0, rgba(coreCol, coreA));
    grad.addColorStop(0.32, rgba(edgeCol, edgeA));
    grad.addColorStop(1.0, `rgba(0,0,0,0)`);

    ctx.beginPath();
    ctx.arc(cx + jx, cy + jy, orbR * 2.4, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();

    // Orb core
    ctx.beginPath();
    ctx.arc(cx + jx, cy + jy, orbR * 0.78, 0, Math.PI * 2);
    ctx.fillStyle = rgba(coreCol, mapClamp(1 - vMove, 0, 1, 0.20, 0.08));
    ctx.fill();

    // Caption
    ctx.save();
    ctx.globalAlpha = mapClamp(1 - vMove, 0, 1, 0.95, 0.35);
    ctx.fillStyle = "rgba(255,255,255,0.72)";
    ctx.font = "14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.textAlign = "center";
    ctx.fillText("move = cloud  •  still = arrival  •  distance = tension", cx, cy + 96);
    ctx.restore();

    requestAnimationFrame(animate);
  }

  // Start visuals
  ctx.fillStyle = "#07070a";
  ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
  animate();

})();
</script>
</body>
</html>
